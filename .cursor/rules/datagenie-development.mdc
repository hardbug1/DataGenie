---
alwaysApply: true
description: DataGenie 프로젝트 전용 개발 규칙 및 가이드라인
---

# DataGenie 프로젝트 개발 규칙

## 🧞‍♂️ 프로젝트 컨텍스트

DataGenie는 **LLM 기반 데이터 분석 플랫폼**으로, 자연어를 통해 데이터베이스 조회 및 Excel 분석을 수행하는 AI 분석 비서입니다.

### 핵심 기술 스택
- **Backend**: FastAPI + SQLAlchemy + Alembic
- **AI/LLM**: OpenAI GPT-4 + LangChain
- **Database**: PostgreSQL (시스템) + 다중 외부 DB 지원
- **Cache**: Redis
- **Frontend**: Gradio
- **Architecture**: Clean Architecture 패턴

## 📁 프로젝트 구조 (MANDATORY)

```
datagenie/
├── app/
│   ├── main.py                    # FastAPI 엔트리포인트
│   ├── domain/                    # 도메인 계층 (Clean Architecture)
│   │   ├── entities/              # 비즈니스 엔티티
│   │   ├── value_objects/         # 값 객체
│   │   └── interfaces/            # 도메인 인터페이스
│   ├── use_cases/                 # 유스케이스 계층
│   │   ├── analysis/              # 분석 관련 유스케이스
│   │   ├── auth/                  # 인증 관련 유스케이스
│   │   └── data_management/       # 데이터 관리 유스케이스
│   ├── infrastructure/            # 인프라 계층
│   │   ├── adapters/              # 어댑터 구현
│   │   └── di_container.py        # 의존성 주입 컨테이너
│   ├── api/                       # API 계층
│   │   └── v1/                    # API v1 엔드포인트
│   ├── schemas/                   # Pydantic 스키마
│   ├── models/                    # SQLAlchemy 모델
│   └── config/                    # 설정 관리
├── tests/                         # 테스트 (미러 구조)
├── docs/                          # 프로젝트 문서
└── requirements/                  # 의존성 관리
```

## ⚡ 필수 개발 원칙

### 1. Clean Architecture 준수 (NON-NEGOTIABLE)
- **Domain 계층**: 외부 의존성 ZERO
- **Use Cases 계층**: 도메인 인터페이스만 의존
- **Infrastructure 계층**: 도메인 인터페이스 구현
- **API 계층**: Use Cases 호출만

### 2. 보안 우선 (SECURITY FIRST)
- **NEVER** 사용자 입력을 직접 SQL에 삽입
- **ALWAYS** 읽기 전용 데이터베이스 연결 사용
- **MANDATORY** 개인정보 자동 마스킹
- **REQUIRED** JWT 토큰 검증

### 3. TDD 필수 (TEST-DRIVEN DEVELOPMENT)
- **RED**: 실패하는 테스트 먼저 작성
- **GREEN**: 테스트 통과하는 최소 코드
- **REFACTOR**: 코드 품질 개선
- **100%** 코드 커버리지 목표

## 🚫 절대 금지 사항

### 1. 보안 위반
```python
# 🚫 NEVER: SQL 인젝션 위험
query = f"SELECT * FROM users WHERE name = '{user_input}'"

# 🚫 NEVER: 개인정보 로깅
logger.info(f"User email: {user.email}")

# 🚫 NEVER: 하드코딩된 비밀번호
DATABASE_PASSWORD = "hardcoded_password"
```

### 2. 아키텍처 위반
```python
# 🚫 NEVER: Domain에서 Infrastructure 의존
from sqlalchemy import Column  # Domain 계층에서 금지

# 🚫 NEVER: Use Case에서 Framework 의존
from fastapi import HTTPException  # Use Case 계층에서 금지
```

### 3. 성능 위반
```python
# 🚫 NEVER: 동기 I/O 작업
result = requests.get(url)  # 비동기 사용 필수

# 🚫 NEVER: 무제한 결과셋
SELECT * FROM large_table  # LIMIT 필수
```

## ✅ 필수 패턴

### 1. API 엔드포인트 패턴
```python
@router.post("/analysis/execute", response_model=AnalysisResponse)
async def execute_analysis(
    request: AnalysisRequest,
    current_user: User = Depends(get_current_user),
    use_case: ExecuteAnalysisUseCase = Depends(get_execute_analysis_use_case)
) -> AnalysisResponse:
    """
    자연어 데이터 분석 실행
    
    Args:
        request: 분석 요청 (질문, 옵션)
        current_user: 인증된 사용자
        use_case: 분석 실행 유스케이스
        
    Returns:
        분석 결과 및 시각화
    """
    try:
        result = await use_case.execute(request, current_user.id)
        return AnalysisResponse(success=True, data=result)
    except PermissionDeniedError as e:
        raise HTTPException(status_code=403, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=422, detail=str(e))
```

### 2. Use Case 패턴
```python
class ExecuteAnalysisUseCase:
    """분석 실행 유스케이스"""
    
    def __init__(
        self,
        query_repository: IQueryRepository,
        analysis_engine: IAnalysisEngine,
        user_permissions: IUserPermissions
    ):
        self._query_repository = query_repository
        self._analysis_engine = analysis_engine
        self._user_permissions = user_permissions
    
    async def execute(self, request: AnalysisRequest, user_id: str) -> AnalysisResult:
        """
        분석 실행 워크플로우
        
        1. 사용자 권한 확인
        2. 도메인 엔티티 생성
        3. 분석 수행
        4. 결과 저장
        5. 응답 반환
        """
        # 1. 권한 확인
        if not await self._user_permissions.can_execute_analysis(user_id):
            raise PermissionDeniedError("분석 실행 권한이 없습니다")
        
        # 2. 도메인 엔티티 생성
        query = AnalysisQuery.create(
            question=request.question,
            user_id=user_id,
            query_type=request.query_type
        )
        
        # 3. 비즈니스 규칙 검증
        if not query.is_valid():
            raise InvalidQueryError("유효하지 않은 질문입니다")
        
        # 4. 분석 수행
        result = await self._analysis_engine.execute_analysis(
            question=query.question,
            connection_id=request.connection_id,
            options=request.options
        )
        
        # 5. 결과 저장
        await self._query_repository.save(query)
        
        return result
```

### 3. 도메인 엔티티 패턴
```python
@dataclass(frozen=True)
class AnalysisQuery:
    """분석 쿼리 도메인 엔티티"""
    
    id: str
    question: str
    user_id: str
    created_at: datetime
    query_type: QueryType
    status: QueryStatus
    
    @classmethod
    def create(
        cls,
        question: str,
        user_id: str,
        query_type: str
    ) -> 'AnalysisQuery':
        """팩토리 메서드로 엔티티 생성"""
        return cls(
            id=str(uuid4()),
            question=question.strip(),
            user_id=user_id,
            created_at=datetime.utcnow(),
            query_type=QueryType(query_type),
            status=QueryStatus.PENDING
        )
    
    def is_valid(self) -> bool:
        """비즈니스 규칙 검증"""
        return (
            len(self.question.strip()) > 0 and
            len(self.question) <= 1000 and
            self.query_type in QueryType and
            self.status in QueryStatus
        )
    
    def can_be_executed_by(self, user_id: str) -> bool:
        """실행 권한 확인"""
        return self.user_id == user_id
```

## 🎯 품질 기준

### 코드 품질 메트릭
- **테스트 커버리지**: 100% (단위 테스트)
- **응답 시간**: < 10초 (단순 쿼리), < 30초 (복잡 분석)
- **에러율**: < 1% (운영 환경)
- **보안 취약점**: 0개

### 성능 기준
- **API 응답 시간**: 95% < 5초
- **데이터베이스 쿼리**: < 30초 (타임아웃)
- **LLM 호출**: < 10초 (캐시 활용)
- **동시 사용자**: 100명 지원

## 📝 커밋 컨벤션

### 커밋 메시지 형식
```
<type>(<scope>): <subject>

<body>

<footer>
```

### 커밋 타입
- `feat`: 새로운 기능
- `fix`: 버그 수정
- `docs`: 문서 변경
- `style`: 코드 포맷팅
- `refactor`: 코드 리팩터링
- `test`: 테스트 추가/수정
- `chore`: 기타 작업

### 예시
```
feat(analysis): 자연어 SQL 생성 기능 구현

- LangChain 기반 SQL Agent 구현
- 스키마 정보 자동 감지
- SQL 인젝션 방지 검증
- 개인정보 자동 마스킹

Closes #42
```

## 🔧 개발 워크플로우

### 0. 개발 환경 설정 (MANDATORY)
```bash
# Conda p3 환경 활성화 (필수)
conda activate p3

# 프로젝트 디렉토리로 이동
cd datagenie

# 의존성 설치
pip install -r requirements/base.txt
pip install -r requirements/test.txt  # 테스트용
```

### 1. 기능 개발 순서
1. **ENV**: conda p3 환경 활성화 확인
2. **RED**: 실패하는 테스트 작성
3. **GREEN**: 테스트 통과하는 최소 코드
4. **REFACTOR**: 코드 품질 개선
5. **COMMIT**: 의미있는 단위로 커밋
6. **REVIEW**: 코드 리뷰 요청

### 2. 브랜치 전략
- `main`: 운영 배포 브랜치
- `develop`: 개발 통합 브랜치
- `feature/*`: 기능 개발 브랜치
- `hotfix/*`: 긴급 수정 브랜치

### 3. 배포 프로세스
1. **개발**: feature 브랜치에서 개발
2. **테스트**: 자동화된 테스트 실행
3. **리뷰**: 코드 리뷰 및 승인
4. **통합**: develop 브랜치로 병합
5. **배포**: main 브랜치로 병합 후 배포

## 🚀 실행 및 테스트 가이드

### DataGenie 실행 방법 (conda p3 환경)
```bash
# 1. conda p3 환경 활성화
conda activate p3

# 2. 프로젝트 디렉토리로 이동
cd datagenie

# 3. 애플리케이션 실행
python -m app.main

# 4. 테스트 실행
pytest tests/ -v --cov=app

# 5. 특정 테스트 실행
pytest tests/domain/entities/test_analysis_query.py -v
```

### 개발 서버 실행
```bash
# FastAPI 개발 서버 (Hot Reload)
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000

# 또는 Python 모듈로 실행
python -m app.main
```

### Phase 3: 핵심 분석 엔진 (✅ 완료)
1. **✅ OpenAI LLM 통합** - GPT-4 API 연동 완료
2. **✅ 자연어 처리 모듈** - 질문 분석 및 분류 완료
3. **✅ SQL 생성 엔진** - LangChain SQL Agent 완료
4. **✅ Excel 분석 엔진** - Pandas 기반 분석 완료
5. **✅ 시각화 엔진** - Plotly 차트 생성 완료

Remember: DataGenie는 **사용자의 데이터 분석을 혁신**하는 플랫폼입니다. 모든 코드는 **보안, 성능, 사용자 경험**을 최우선으로 고려해야 합니다.